---
layout: post
title: "25年7月复习与总结"
date:  2025-07-08 22:05:00 +0800

categories: jekyll update
---  

## 7.8：2904-最短且字典序最小的美丽子字符串

> 给你一个二进制字符串 `s` 和一个正整数 `k` 。
>
> 如果 `s` 的某个子字符串中 `1` 的个数恰好等于 `k` ，则称这个子字符串是一个 **美丽子字符串** 。
>
> 令 `len` 等于 **最短** 美丽子字符串的长度。
>
> 返回长度等于 `len` 且字典序 **最小** 的美丽子字符串。如果 `s` 中不含美丽子字符串，则返回一个 **空** 字符串。
>
> 对于相同长度的两个字符串 `a` 和 `b` ，如果在 `a` 和 `b` 出现不同的第一个位置上，`a` 中该位置上的字符严格大于 `b` 中的对应字符，则认为字符串 `a` 字典序 **大于** 字符串 `b` 。
>
> - 例如，`"abcd"` 的字典序大于 `"abcc"` ，因为两个字符串出现不同的第一个位置对应第四个字符，而 `d` 大于 `c` 。

**Solution**：

````java
class Solution {
    public String shortestBeautifulSubstring(String s, int k) {
        if (s.replace("0", "").length() < k) {
            return "";
        }

        char[] S = s.toCharArray();
        String ans = s;
        int cnt1 = 0, left = 0;
        for (int right = 0; right < s.length(); right++) {
            cnt1 += S[right] - '0';
            while (cnt1 > k || S[left] == '0') {
                cnt1 -= S[left++] - '0';
            }
            if (cnt1 == k) {
                String t = s.substring(left, right + 1);
                if (t.length() < ans.length() || t.length() == ans.length() && t.compareTo(ans) < 0) {
                    ans = t;
                }
            }
        }
        return ans;
    }
}
````

### Record：

- 首先是对可行性的分析：
  - 当接受的字串包含的“1”不足k个时，显然找不到满足要求子串
  - 否则一定有解
- 其次是窗口的维护和更新：
  - 维护一个滑动窗口，记录窗口内的“1”的count数（**其中对count的处理非常值得学习，利用“0”和“1”的差值来记录和更新count**）
  - 当窗口条件被破坏时缩小窗口：
    - 这里有两个破坏窗口的条件，一是count的值超出了k的值
    - 二是比较隐含的一个条件，注意到提议中要求返回最短的串，也就是说不需要考虑先导零的存在，也就是说，窗口左侧是“0”也肯定不满足条件，破坏了窗口
- 最后是结果值的更新：
  - 使用了substring的方法，这个方法我有考虑到但是没有做到这么好
  - 在长度更小时，更新结果串
  - 长度相等时比较字典序：
    - 比较字典序的处理我卡了很久没有想出来，忘记了java提供的`compareTo`的API了

## 7.9: 1234-替换子串得到平衡字符串

>有一个只含有 `'Q', 'W', 'E', 'R'` 四种字符，且长度为 `n` 的字符串。
>
>假如在该字符串中，这四个字符都恰好出现 `n/4` 次，那么它就是一个「平衡字符串」。
>
> 
>
>给你一个这样的字符串 `s`，请通过「替换一个子串」的方式，使原字符串 `s` 变成一个「平衡字符串」。
>
>你可以用和「待替换子串」长度相同的 **任何** 其他字符串来完成替换。
>
>请返回待替换子串的最小可能长度。
>
>如果原字符串自身就是一个平衡字符串，则返回 `0`。

### Solution：

```java
class Solution {
    public int balancedString(String s) {
        int n = s.length();
        char[] S = s.toCharArray();
        int cntQ = 0;int cntW = 0;
        int cntE = 0;int cntR = 0;

        for (char i : S) {
            switch (i) {
                case 'Q':cntQ++;break;
                case 'W':cntW++;break;
                case 'E':cntE++;break;
                case 'R':cntR++;break;
            }
        }
        //已平衡返回0；
        if (cntQ == (n / 4) && cntW == (n / 4) && cntE == (n / 4) && cntR == (n / 4)) {
            return 0;
        }

        int left = 0, right = 0;
        int len = n;
        int Threshold = n / 4;

        for (right = 0; right < n; right++) {
            switch (S[right]) {
                case 'Q':cntQ--;break;
                case 'W':cntW--;break;
                case 'E':cntE--;break;
                case 'R':cntR--;break;
            }
            while (cntQ <= Threshold && cntW <= Threshold && cntE <= Threshold && cntR <= Threshold) {
                len = len < right - left + 1 ? len : right - left + 1;
                switch (S[left]) {
                    case 'Q':cntQ++;break;
                    case 'W':cntW++;break;
                    case 'E':cntE++;break;
                    case 'R':cntR++;break;
                }
                left++;
            }
        }
        return len;
    }
}
```

### Record：

- 首先注意到一个基本事实：被替换字串+剩余串 = 原有串
- 要使得替换完后的串是平衡字符串，那么**剩余串中QWER的数量就都应该小于n/4** ，这样就可以由被替换的部分补偿
- 在此基础上就要考虑滑动窗口的维护条件了，这里卡了很久
- 根据上述很显然，窗口的目标是使得窗口外的QWER小于阈值n/4
- 要有这么一个认识：滑动窗口相当于在维护一个**队列**。右指针的移动可以视作**入队**，左指针的移动可以视作**出队**
- 我们根据这个出入队的动作修改count的数值直到满足条件，然后开始缩小窗口直到条件被破坏
- 先扩展窗口满足窗口条件，然后缩小直到条件被破坏，重复该过程直到遍历完字符串