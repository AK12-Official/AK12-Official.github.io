---
layout: post
title: "25年7月复习与总结"
date:  2025-02-08 22:05:00 +0800
categories: jekyll update
---  

## 7.8：2904-最短且字典序最小的美丽子字符串

> 给你一个二进制字符串 `s` 和一个正整数 `k` 。
>
> 如果 `s` 的某个子字符串中 `1` 的个数恰好等于 `k` ，则称这个子字符串是一个 **美丽子字符串** 。
>
> 令 `len` 等于 **最短** 美丽子字符串的长度。
>
> 返回长度等于 `len` 且字典序 **最小** 的美丽子字符串。如果 `s` 中不含美丽子字符串，则返回一个 **空** 字符串。
>
> 对于相同长度的两个字符串 `a` 和 `b` ，如果在 `a` 和 `b` 出现不同的第一个位置上，`a` 中该位置上的字符严格大于 `b` 中的对应字符，则认为字符串 `a` 字典序 **大于** 字符串 `b` 。
>
> - 例如，`"abcd"` 的字典序大于 `"abcc"` ，因为两个字符串出现不同的第一个位置对应第四个字符，而 `d` 大于 `c` 。

**Solution**：

````java
class Solution {
    public String shortestBeautifulSubstring(String s, int k) {
        if (s.replace("0", "").length() < k) {
            return "";
        }

        char[] S = s.toCharArray();
        String ans = s;
        int cnt1 = 0, left = 0;
        for (int right = 0; right < s.length(); right++) {
            cnt1 += S[right] - '0';
            while (cnt1 > k || S[left] == '0') {
                cnt1 -= S[left++] - '0';
            }
            if (cnt1 == k) {
                String t = s.substring(left, right + 1);
                if (t.length() < ans.length() || t.length() == ans.length() && t.compareTo(ans) < 0) {
                    ans = t;
                }
            }
        }
        return ans;
    }
}
````

### 记录：

- 首先是对可行性的分析：
  - 当接受的字串包含的“1”不足k个时，显然找不到满足要求子串
  - 否则一定有解
- 其次是窗口的维护和更新：
  - 维护一个滑动窗口，记录窗口内的“1”的count数（**其中对ocunt的处理非常值得学习，利用“0”和“1”的差值来记录和更新count**）
  - 当窗口条件被破坏时缩小窗口：
    - 这里有两个破坏窗口的条件，一是count的值超出了k的值
    - 二是比较隐含的一个条件，注意到提议中要求返回最短的串，也就是说不需要考虑先导零的存在，也就是说，窗口左侧是“0”也肯定不满足条件，破坏了窗口
- 最后是结果值的更新：
  - 使用了substring的方法，这个方法我有考虑到但是没有做到这么好
  - 在长度更小时，更新结果串
  - 长度相等时比较字典序：
    - 比较字典序的处理我卡了很久没有想出来，忘记了java提供的`compareTo`的API了